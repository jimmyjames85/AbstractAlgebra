package edu.iastate.math301.util;

import static edu.iastate.math301.util.Util.cloneList;
import static edu.iastate.math301.util.Util.cloneSet;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

public class Util
{

	public static void println()
	{
		println("");
	}
	public static void println(Object o)
	{
		System.out.println(o.toString());
	}
	public static void print(Object o)
	{
		System.out.print(o.toString());
	}
	
	public static long factorial(int n)
	{
		if(n<0)
			throw new IllegalArgumentException("n must not be negative");
		
		if(n==0)
			return 1;
		
		return n*factorial(n-1);
	}
	
	public static <T> Set<T> intersection(Set<T> a, Set<T> b)
	{
		Set<T> ret = new TreeSet<T>();

		if (b.size() < a.size())
		{
			Set<T> tmp = a;
			a = b;
			b = tmp;
		}

		// a now points to the smaller of the two sets

		for (T elem : a)
		{
			if (b.contains(elem))
				ret.add(elem);
		}

		return ret;
	}

	public static long gcd(long a, long b)
	{
		if (a <= 0 || b <= 0)
			throw new IllegalArgumentException();

		while (b > 0)
		{
			long temp = b;
			b = a % b; // % is remainder
			a = temp;
		}
		return a;
	}

	public static long lcm(long a, long b)
	{
		if (a <= 0 || b <= 0)
			throw new IllegalArgumentException();

		return a * (b / gcd(a, b));
	}
	
	public static Set<Integer> cloneSet(Set<Integer> src)
	{
		Set<Integer> ret = new TreeSet<Integer>();

		for (int i : src)
			ret.add(i);

		return ret;
	}

	public static List<Integer> cloneList(List<Integer> src)
	{
		ArrayList<Integer> ret = new ArrayList<Integer>();

		for (int i : src)
			ret.add(i);

		return ret;
	}
	

	/**
	 * 
	 * @param a
	 *            - generator
	 * @param n
	 *            - modulus
	 *            
	 * @return the order of a in U(n)
	 * 
	 * (-1 means infinite order)
	 */
	public static int orderOf_a_inUnitsOfN(int a, int n)
	{
		if (a <= 0 || n <= 0 || a > n)
			throw new IllegalArgumentException();

		int cur = a % n;
		int i = 1;
		while (cur != 1 && i <= n)
		{
			cur = cur * a % n;
			i++;
		}

		if (i == n + 1)
			i = -1;

		return i;
	}
	

	public static Set<Integer> unitsOfN(int n)
	{
		if (n <= 0)
			throw new IllegalArgumentException();

		TreeSet<Integer> ret = new TreeSet<Integer>();

		for (int i = 1; i < n; i++)
			if (gcd(i, n) == 1)
				ret.add(i);

		return ret;
	}

	/**
	 * 
	 * @param a
	 *            - generator
	 * @param n
	 *            - modulus
	 * @return a cyclic set generated by a 
	 * 
	 * <a>={a, a^2, a^3...e}   for a in U(n)
	 */
	public static Set<Integer> gen_a_inUnitsOfN(int a, int n)
	{
		if (a <= 0 || n <= 0)
			throw new IllegalArgumentException();

		TreeSet<Integer> ret = new TreeSet<Integer>();

		a = a % n;

		int cur = a;

		ret.add(cur);
		cur = cur * a % n;
		while (cur != a)
		{
			ret.add(cur);
			cur = cur * a % n;
		}

		return ret;
	}
	

	private static void permutate(Set<Integer> available, ArrayList<Integer> curPermutation, Set<List<Integer>> store)
	{
		//if nothing available then store current permutation and return
		if (available.size() == 0)
		{
			store.add(cloneList(curPermutation));
			return;
		}

		Iterator<Integer> itr = available.iterator();
		while (itr.hasNext())
		{
			//add to permutation
			int cur = itr.next();
			curPermutation.add(cur);

			//remove from available set
			Set<Integer> nowAvailable = cloneSet(available);
			nowAvailable.remove(cur);

			//remove from permutation and loop again
			permutate(nowAvailable, curPermutation, store);
			if (curPermutation.size() != 0)
				curPermutation.remove(curPermutation.size() - 1);
		}
	}

	public static Set<List<Integer>> createSymmetricGroup(int n)
	{
		//Set<List<Integer>> 
		Set<List<Integer>> sN = (Set<List<Integer>>) new TreeSet<List<Integer>>(new Comparator<List<Integer>>()
		{
			@Override
			public int compare(List<Integer> o1, List<Integer> o2)
			{
				return o1.toString().compareTo(o2.toString());
			}
		});

		if (n < 1)
			throw new IllegalArgumentException("n must be positive");

		Set<Integer> available = new TreeSet<Integer>();
		for (int i = 1; i <= n; i++)
			available.add(i);

		ArrayList<Integer> curPermutation = new ArrayList<Integer>();
		permutate(available, curPermutation, sN);

		return sN;
	}

	

}
